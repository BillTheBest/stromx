# -*- coding: utf-8 -*-
"""
Created on Mon Apr  1 18:19:38 2013

@author: matz
"""

import sys

import cvtype
import datatype
import document
import generator
import package
import test

# default test data
DT = test.Default()

# findChessboardCorners
image = package.Argument(
    "image", "Image", cvtype.Mat(), datatype.Image()
)
sizex = package.NumericParameter(
    "patternSizeX", "Pattern size X", cvtype.Int(), datatype.UInt32(), default = 7,
    minValue = 1
)
sizey = package.NumericParameter(
    "patternSizeY", "Pattern size Y", cvtype.Int(), datatype.UInt32(), default = 5,
    minValue = 1
)
size = package.Size(sizex, sizey)
corners = package.MatrixArgument(
    "corners", "Corners", cvtype.Mat(channels = 2), datatype.Float32Matrix(),
    cols = 2
)
chessboard_bw = test.ImageFile("chess.png", grayscale = True)
chessboard_color = test.ImageFile("chess.png")
allocate = package.Option(
    "allocate", "Allocate",
    [package.Input(image), size, package.Allocation(corners)],
    tests = [
        [chessboard_bw, DT, DT, DT],
        [chessboard_color, DT, DT, DT]
    ]
)
findChessboardCorners = package.Method(
    "findChessboardCorners", options = [allocate]
)

# solvePnP
objectPoints = package.MatrixArgument(
    "objectPoints", "Object points", cvtype.Mat(channels = 3),
    datatype.Float32Matrix(), cols = 3
)
imagePoints = package.MatrixArgument(
    "imagePoints", "Image points", cvtype.Mat(channels = 2),
    datatype.Float32Matrix(), cols = 2
)
pointSizeCheck = document.Document(
"""
if (objectPointsCastedData->rows() != imagePointsCastedData->rows())
{
    throw runtime::InputError(OBJECT_POINTS, *this, "Object and image points must have the same number of rows.");
}
""")
cameraMatrix = package.MatrixParameter(
    "cameraMatrix", "Camera matrix", datatype.FloatMatrix(),
    default = "cvsupport::Matrix::zeros(3, 3, runtime::Matrix::FLOAT_32)",
    rows = 3, cols = 3
)
distCoeffs = package.MatrixParameter(
    "distCoeffs", "Distortion coefficients", datatype.FloatMatrix(),
    default = "cvsupport::Matrix::zeros(1, 5, runtime::Matrix::FLOAT_32)",
    rows = 1, cols = 5,
)
rvec = package.MatrixArgument(
    "rvec", "Rotation", cvtype.Mat(channels = 2), datatype.Float64Matrix(),
    rows = 3, cols = 1
)
tvec = package.MatrixArgument(
    "tvec", "Translation", cvtype.Mat(channels = 2), datatype.Float64Matrix(),
    rows = 3, cols = 1
)
chess_corners = test.MatrixFile("chess_corners_1.npy")
chess_corners_3d = test.MatrixFile("chess_corners_3d.npy")
camera_matrix_64f = test.MatrixFile("camera_matrix_64f.npy")
dist_coeffs_64f = test.MatrixFile("dist_coeffs_64f.npy")
camera_matrix_32f = test.MatrixFile("camera_matrix_32f.npy")
dist_coeffs_32f = test.MatrixFile("dist_coeffs_32f.npy")

allocate = package.Option(
    "allocate", "Allocate",
    [package.Input(objectPoints), package.Input(imagePoints), cameraMatrix,
     distCoeffs, package.Allocation(rvec), package.Allocation(tvec)],
    inputCheck = pointSizeCheck,
    tests = [
        [chess_corners_3d, chess_corners, camera_matrix_64f, dist_coeffs_32f, DT, DT],
        [chess_corners_3d, chess_corners, camera_matrix_32f, dist_coeffs_64f, DT, DT]
    ]
)
solvePnP = package.Method(
    "solvePnP", options = [allocate]
)

calib3d = package.Package(
    "cvcalib3d", 0, 0, 1,
    methods = [
        calibrateCamera,
        findChessboardCorners,
        solvePnP
    ],
    testFiles = [
        "chess.png", # 24-bit color
        "chess_corners_1.npy", # 32-bit float
        "chess_corners_2.npy",
        "chess_corners_3.npy",
        "chess_corners_4.npy",
        "chess_corners_5.npy",
        "chess_corners_6.npy",
        "chess_corners_7.npy",
        "chess_corners_3d.npy",
        "camera_matrix_64f.npy",
        "dist_coeffs_64f.npy",
        "camera_matrix_32f.npy",
        "dist_coeffs_32f.npy"
    ]
)

package = calib3d

if __name__ == '__main__':
    if len(sys.argv) > 1:
        for arg in sys.argv[1:]:
            generator.generateMethodFiles(package, globals()[arg])
    else:
        generator.generatePackageFiles(package) 
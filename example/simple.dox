/** \page simple Simple

\em Streams are the main objects of the \em strom library. All other objects belong either directly or indirectly to a stream. A stream consists of operators each of which can have several inputs and several outputs. An example of a very simple stream is given in the following image:

\image html example/simple.png

The operator \em Counter has the single output node \em OUTPUT which is connected to the only input node (fittingly called \em INPUT) of \em PeriodicDelay. This means that every output data which is produced at the output of \em PeriodicDelay will be transported to the input of \em Counter. Data which is transported to an input will stay there and \em block this input until its operator starts to process the data.

However operators in \em strom are \em passive objects, i.e. they do not process any data on their own but need a \em thread which \em executes them. Besides operators, threads are the second important building blocks of a stream. Each input node of an operator can be assigned to a thread. When activated the thread visits each of its input node sequentially and starts again with the first when they last node has been reached. When a thread visits an input node of an operator it acts according to the following two steps:

- The thread looks up to which output the input is connected. If there is no data at this output the thread \em executes the operator to which the output belongs to. This should produce some data at the output in question.

- Now the thread moves the data which was either present at the output of the source operator or has been produced by executing the source operator and passes it to the input node which it currently visits. However, it could happen that data has already assigned to this node, i.e. the input node is blocked. In this case the thread will execute the operator of the input node hoping that this improves the situation.

In other words, the process of transporting data from input nodes to output nodes implicitely executes the operators of these nodes to make sure (1) that there is enough data at the outputs and (2) that the data at the inputs is removed in time.

\note
Not every input node must be assigned to a thread. However, if data is required at an input which is not part of a thread the input must be fed manually by the user by calling Operator::setInputData(). Something similar holds for outputs which are not connected to inputs (more accurate, to inputs which are assigned to a thread). If data is waiting at such an output (which prevents the operator from being executed) it can be removed by the client using Operator::clearOutputData().

The \em simple tutorial assembles the stream in the image above and operates it. The \em Counter operator in the stream simply pushes an integer to its output each time it is executed. With each call it increments the integer by one. The \em PeriodicDelay operator simple passes data at its input to its output. However, it makes sure that new data appears at the output at most once within a certain amount of time (one second in this example). In this sense it acts as a timer, which delays the transport of data by predefined timespan.
In the following, the source code of \em simple.cpp is printed with comments under each part.

\code
#include <strom/Stream.h>
#include <strom/Operator.h>
#include <strom/Thread.h>
#include <strom/ReadAccess.h>

#include <base/Counter.h>
#include <base/PeriodicDelay.h>

#include <iostream>
\endcode

As usual the program starts be including the required header files. Strom uses a fine grained approach to the inclusion of headers, i.e. only the necessary headers are included by the library headers and forward declarations are used wherever possible. As a consequence the headers of all classes which are used in the code are included here.

The first four headers are part of the strom core library. This library provides all infrastructure for streams, operator and threads but does not contain any operators. The operators which are used in the example are part of the strom base library which are imported next. The final header is necessary to write the results of the running stream to the standard output.


\code
int main (int argc, char* argv[])
{
    using namespace strom;
    
    Stream stream;
\endcode

The main function starts by importing the namespace strom which relieves us from prefixing each all calls to the core library with \em strom::. The next step creates an empty stream object which will populated with operators and threads in the following code.

\code
    Operator* source = new Operator(new base::Counter);
    source->initialize();
    stream.addOperator(source);
    
    Operator* timer = new Operator(new base::PeriodicDelay);
    timer->initialize();
    stream.addOperator(timer);
\endcode

First, the source is operator is allocated and initialized. Initializing can possibly change important properties of an operator such as the number and type of its output and input nodes. This is the reason why only initialized operator can be added to a stream. Note that when an operator is added to a stream the stream assumes ownership of it. I.e. its not advisable to add an operator which is allocated on the stack to a stream. This would result in a crash when the stream is destroyed or when the operator goes out of scope. In other words, always use \em new to allocate an operator before adding it to the stream and do not clean it up because the stream will take care of that.

\code
    timer->setParameter(base::PeriodicDelay::PERIOD, UInt32(1000));
\endcode

In the next step the time delay of the timer operator is set to one second. 

\note
Each parameter has an access mode which controls when the associated value can be written and read. In case of the period of \em PeriodicCounter the access mode is Parameter::ACTIVATED_WRITE which means that the parameter can be written (and read) at any time as soon the operator is initialized.

\code    
    stream.connect(source, base::Counter::OUTPUT, timer, base::PeriodicDelay::INPUT);
\endcode

This line connects the output of the counter to the input of the \c timer operator. Note that input and output nodes are identified by the operator the belong to (\c source and \c timer) and their IDs (base::Counter::OUTPUT and base::PeriodicDelay::INPUT).
  
\code  
    Thread* thread = stream.addThread();
    thread->addNode(timer, base::PeriodicDelay::INPUT);
\endcode

Now the operating thread is added to the stream. In the next line the input node of \em timer is added as the only input node which is operated by \em thread. As before the input node is addressed by its operator and its ID.

\code
    stream.start();
\endcode

This step starts all threads (i.e. is one in our case) of the stream. The thread starts to process its input nodes immediately. As mentioned in the introduction it implicitely executes the operators in the stream and moves processed data to the output of \em timer. The following loop gets this data from the output and writes it to the standard input.
   
\code   
    for(unsigned int i = 0; i < 5; ++i)
    {
        DataContainer data = timer->getOutputData(base::PeriodicDelay::OUTPUT);
        ReadAccess<UInt32> count(data);
        timer->clearOutputData(base::PeriodicDelay::OUTPUT);
        
        std::cout << "Received " <<  (unsigned int)(count()) << std::endl;
    }
\endcode
    
\code  
    stream.stop();
    stream.join();
}
\endcode

Now you can proceed to \ref file.
*/

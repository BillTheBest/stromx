/** \page operator Operator

- \ref operator_declare
- \ref operator_implement
- \ref operator_deploy

In this example the stream in previous examples shall be extended by an operator \em Add which adds to a constant to the number currently processed:

\image html example/operator.png

However such an operator is not defined in the package \em Base which provided all operators which have been used so far. Thus, a custom operator \em Add must be implemented. It will be the single member of the new package \em Math.

\section operator_declare Declaring the operator

A custom operator is implemented by defining an <em>operator kernel</em>. In contrast to operators, operator kernel do not have to be aware of multiple threads which access them. All concurrent accesses are handled by the strom::Operator class which wraps the operator kernels. This simplifies the definition of custom operators.

The new operator kernel is declared in the header file <em>Add.h</em>:

\code
#ifndef MATH_ADD_H
#define MATH_ADD_H

#include <strom/OperatorKernel.h>
#include <strom/Primitive.h>

namespace strom
{
    class DataContainer;
}

namespace math
{
    class Add : public strom::OperatorKernel
    {
\endcode

The kernel will be a member of the package \em Math and is therefore added to the namespace \em math.
Operator kernels are derived from strom::OperatorKernel which is the common base class of all operator kernels. 

\code
    public:
        enum InputId
        {
            INPUT
        };
        
        enum OutputId
        {
            OUTPUT
        };
        
        enum ParameterId
        {
            OFFSET
        };
        
\endcode

Each input, output and parameter of the operator is identified by an ID. Here each of these IDs is 0, but any other value is possible as long as it is unique within its category (inputs, outputs, parameters).

\code
        Add();
        
        virtual OperatorKernel* const clone() const { return new Add; }
        virtual void execute(strom::DataProvider& provider);

        virtual void setParameter(unsigned int id, const strom::Data& value);
        virtual const strom::Data& getParameter(unsigned int id);
\endcode

First the default constructor is declared. The functions strom::OperatorKernel::clone() and strom::OperatorKernel::execute() are abstract in strom::OperatorKernel and must be defined in each custom operator kernel. Because \em Add has one parameter the following functions to read and write parameters must be implemented.

\code
    private:
        static const std::vector<const strom::Description*> setupInputs();
        static const std::vector<const strom::Description*> setupOutputs();
        static const std::vector<const strom::Parameter*> setupParameters();
        
        static const std::string TYPE;
        static const std::string PACKAGE;
        static const strom::Version VERSION;                         
        
        strom::UInt32 m_offset;
    };
}

#endif // MATH_ADD_H
\endcode

The subsequent private declarations are for internal use only and will be explained when used in the implementation of \em Add.

\section operator_implement Implementing the operator

\code
#include "Add.h"

#include <strom/Primitive.h>
#include <strom/OperatorException.h>
#include <strom/DataContainer.h>
#include <strom/DataProvider.h>
#include <strom/Id2DataPair.h>
#include <strom/Id2DataComposite.h>
#include <strom/ReadAccess.h>

using namespace strom;

namespace math
{
    const std::string Add::TYPE("Add");
    const std::string Add::PACKAGE("Math");
    const Version Add::VERSION(1, 0);
    
    Add::Add()
      : OperatorKernel(TYPE, PACKAGE, VERSION, setupInputs(), setupOutputs(), setupParameters())
    {
    }

    void Add::setParameter(unsigned int id, const Data& value)
    {
        try
        {
            switch(id)
            {
            case OFFSET:
                m_offset = dynamic_cast<const UInt32&>(value);
                break;
            default:
                throw WrongParameterId(id, *this);
            }
        }
        catch(std::bad_cast&)
        {
            throw WrongParameterId(id, *this);
        }
    }

    const Data& Add::getParameter(unsigned int id)
    {
        switch(id)
        {
        case OFFSET:
            return m_offset;
        default:
                throw WrongParameterId(id, *this);
        }
    }  
    
    void Add::execute(DataProvider& provider)
    {
        Id2DataPair inputMapper(INPUT);
        provider.receiveInputData(inputMapper);
        
        ReadAccess<UInt32> input(inputMapper.data());
        
        Data* result = new UInt32((unsigned int)(input()) + (unsigned int)(m_offset));
        
        DataContainer outContainer(result);
       
        Id2DataPair output(OUTPUT, outContainer);
        provider.sendOutputData(output);
    }
    
    const std::vector<const strom::Description*> Add::setupInputs()
    {
        std::vector<const Description*> inputs;
        
        Description* input = new Description(INPUT, DataVariant::UINT_32);
        input->setName("Input");
        inputs.push_back(input);
        
        return inputs;
    }
    
    const std::vector<const Description*> Add::setupOutputs()
    {
        std::vector<const Description*> outputs;
        
        Description* output = new Description(OUTPUT, DataVariant::UINT_32);
        output->setName("Output");
        outputs.push_back(output);
        
        return outputs;
    }
    
    const std::vector<const Parameter*> Add::setupParameters()
    {
        std::vector<const strom::Parameter*> parameters;
        
        Parameter* offset = new Parameter(OFFSET, DataVariant::UINT_32);
        offset->setName("Offset");
        offset->setAccessMode(strom::Parameter::ACTIVATED_WRITE);
        parameters.push_back(offset);
                                    
        return parameters;
    }
} 
\endcode

\section operator_deploy Deploying the operator

\code
#include <strom/Factory.h>
#include <strom/XmlReader.h>
#include <strom/Stream.h>
#include <strom/Strom.h>
#include <strom/Operator.h>
#include <strom/Primitive.h>
#include <strom/ReadAccess.h>

#include <base/Base.h>

#include "math/Add.h"

#include <iostream>

int main (int argc, char* argv[])
{
    using namespace strom;
   
    Factory* factory = new Factory;
    
    registerStrom(factory);
    registerBase(factory);
    
    OperatorKernel* op = new math::Add;
    factory->registerOperator(op);
    
    Stream* stream = XmlReader(factory).read("operator.xml");
    
    stream->start();
    
    Operator* timer = stream->operators()[2];
    
    for(unsigned int i = 0; i < 5; ++i)
    {
        DataContainer data = timer->getOutputData(0);
        ReadAccess<UInt32> count(data);
        timer->clearOutputData(0);
        
        std::cout << "Received " <<  (unsigned int)(count()) << std::endl;
    }
    
    stream->stop();
    stream->join();
    
    delete stream;
}
\endcode

*/

/** \page operator Operator

- \ref operator_declare
- \ref operator_implement
- \ref operator_deploy

In this example the stream in previous examples shall be extended by an operator \em Add which adds a constant offset to the number currently processed:

\image html example/operator.png

However such an operator is not defined in the package \em Base which provided all operators which have been used so far. Thus, a custom operator \em Add must be implemented. It will be the single member of the new package \em Math.

\section operator_declare Declaring the operator

A custom operator is implemented by defining an <em>operator kernel</em>. In contrast to operators, operator kernels do not have to be thread-safe. All concurrent accesses are handled by the strom::Operator class which wraps the operator kernels. This simplifies the definition of custom operators.

The new operator kernel is declared in the header file <em>Add.h</em>:

\code
#ifndef MATH_ADD_H
#define MATH_ADD_H

#include <strom/OperatorKernel.h>
#include <strom/Primitive.h>

namespace strom
{
    class DataContainer;
}

namespace math
{
    class Add : public strom::OperatorKernel
    {
\endcode

The kernel will be a member of the package \em Math. It seems to be a good practice to add all operators of a package to a common namespace which in this case is consequently called \em math.

All operator kernels are derived from strom::OperatorKernel.

\code
    public:
        enum InputId
        {
            INPUT
        };
        
        enum OutputId
        {
            OUTPUT
        };
        
        enum ParameterId
        {
            OFFSET
        };
        
\endcode

Each input, output and parameter of the operator is identified by an ID. Here each of these IDs is 0, but any other value is possible as long as it is unique within its category (i.e. inputs, outputs, parameters).

\code
        Add();
        
        virtual OperatorKernel* const clone() const { return new Add; }
        virtual void execute(strom::DataProvider& provider);

        virtual void setParameter(unsigned int id, const strom::Data& value);
        virtual const strom::Data& getParameter(unsigned int id);
\endcode

First the default constructor is declared. The functions strom::OperatorKernel::clone() and strom::OperatorKernel::execute() are abstract in strom::OperatorKernel and must be defined in each custom operator kernel. The subsequent functions must be implemented to support reading and writing the paramter of  \em Add.

\code
    private:
        static const std::vector<const strom::Description*> setupInputs();
        static const std::vector<const strom::Description*> setupOutputs();
        static const std::vector<const strom::Parameter*> setupParameters();
        
        static const std::string TYPE;
        static const std::string PACKAGE;
        static const strom::Version VERSION;                         
        
        strom::UInt32 m_offset;
    };
}

#endif // MATH_ADD_H
\endcode

The subsequent private declarations are for internal use only and will be explained when used in the implementation of \em Add.

\section operator_implement Implementing the operator

The operatorar \em Add is implemented in <em>Add.cpp</em>.
\code
#include "Add.h"

#include <strom/Primitive.h>
#include <strom/OperatorException.h>
#include <strom/DataContainer.h>
#include <strom/DataProvider.h>
#include <strom/Id2DataPair.h>
#include <strom/Id2DataComposite.h>
#include <strom/ReadAccess.h>

\endcode

First all necessary headers are included. The subsequent \em using allows to access the members of the \em strom library without the prefix \c strom::

\code
namespace math
{
    const std::string Add::TYPE("Add");
    const std::string Add::PACKAGE("Math");
    const Version Add::VERSION(1, 0);
\endcode

Each operator kernel provides exports its type, the package it belongs to and its version. This information must be the same for each instance of specific operator class and is naturally stored in static variables. This data will be passed to the constructor of strom::OperatorKernel.

Moreover, the constructor of strom::OperatorKernel accepts vectors of descriptions of the inputs, outputs and parameters of the operator kernel. These descriptions are \em not required to be the same for each instance of a specific operator class and can change during the lifetime of operator objects. As a consequence they can not be static variables but must be allocated for each class instance. The following helper functions take care of this allocations. In the case of \em Add the initial descriptions are the same for each class instance. Thus, the initialization functions can be static.

\code
    const std::vector<const strom::Description*> Add::setupInputs()
    {
        std::vector<const strom::Description*> inputs;
        
        strom::Description* input = new strom::Description(INPUT, strom::DataVariant::UINT_32);
        input->setName("Input");
        inputs.push_back(input);
        
        return inputs;
    }
    
    const std::vector<const strom::Description*> Add::setupOutputs()
    {
        std::vector<const strom::Description*> outputs;
        
        strom::Description* output = new strom::Description(OUTPUT, strom::DataVariant::UINT_32);
        output->setName("Output");
        outputs.push_back(output);
        
        return outputs;
    }
    
    const std::vector<const strom::Parameter*> Add::setupParameters()
    {
        std::vector<const strom::Parameter*> parameters;
        
        strom::Parameter* offset = new strom::Parameter(OFFSET, strom::DataVariant::UINT_32);
        offset->setName("Offset");
        offset->setAccessMode(strom::Parameter::ACTIVATED_WRITE);
        parameters.push_back(offset);
                                    
        return parameters;
    }
\endcode

Each initialization function allocates an empty vector which contains pointers to strom::Description objects (in the case of inputs and outputs) or strom::Parameter objects (for parameters). Input and output descriptions only contain their ID and names. Parameters additionally provide information about their access mode. Here strom::Parameter::ACTIVATED_WRITE means that the parameter can be read and written while the operator is initialized or activated. There exist subclasses of strom::Parameter to describe specific types of parameters in more detail. One example is strom::NumericParameter which contains information about the minimal and maximal value a parameter can be set to.

\code
    Add::Add()
      : OperatorKernel(TYPE, PACKAGE, VERSION, setupInputs(), setupOutputs(), setupParameters())
    {
    }
\endcode

The constructor of \em Add simply passes all information which was setup above to the constructor of operator kernel.

\note
Not all inputs, outputs and parameters have to be passed to the constructor of strom::OperatorKernel. There exists the possibility to add further information during initialization of the operator (by overloading strom::OperatorKernel::initialize()). This means that an operator can be set up in a two stage process. After instantiation (but before initialization) some parameter descriptions are allocated and the corresponding parameters can be set. Depending on the value of these parameters the operators assigns further inputs, outputs and parameters to itself during initialization.
An example is an operator which merges several inputs to one output. After instantation the operator has no inputs but a parameter which defines the number of inputs. Only during initialization these inputs are actually allocated.

\code
    void Add::setParameter(unsigned int id, const strom::Data& value)
    {
        try
        {
            switch(id)
            {
            case OFFSET:
                m_offset = strom::data_cast<const strom::UInt32&>(value);
                break;
            default:
                throw strom::WrongParameterId(id, *this);
            }
        }
        catch(strom::BadCast&)
        {
            throw strom::WrongParameterId(id, *this);
        }
    }
\endcode

The parameter \em Add supports only one parameter. To support more parameter further \c case statements have to be added to the \c switch statement. The value of the parameter \c OFFSET is internally stored as member of type strom::UInt32. Because the parameter \c value is of type strom::Data it must be down-casted to the correct type. The function strom::data_cast() works exactly as dynamic_cast() but throws a strom::BadCast instead of std::bad_cast.

\code
    const strom::Data& Add::getParameter(const unsigned int id) const
    {
        switch(id)
        {
        case OFFSET:
            return m_offset;
        default:
            throw strom::WrongParameterId(id, *this);
        }
    }  
\endcode

The functions to read a parameter follows the same pattern as writing it.

\note
As mentioned above operator kernels do not have to be thread-safe. It is guaranteed that strom::OperatorKernel::getParameter() and strom::OperatorKernel::setParameter() are never called during execution of the operator.

\code
    void Add::execute(strom::DataProvider& provider)
    {
        strom::Id2DataPair inputMapper(INPUT);
        provider.receiveInputData(inputMapper);
\endcode

The actual work done by \em Add happens in \c execute(). There the input data is processed and the result is passed to the operator output. The input data is obtained from a strom::DataProvider object. To request the data of an specific input a strom::Id2DataPair object \c inputMapper is instantiated with the ID of the input in question. The data provider looks up the corresponding input and waits for input data. If the data arrives it stores in \c inputMapper.

\code
        strom::ReadAccess<strom::UInt32> input(inputMapper.data());

        strom::Data* result = new strom::UInt32((unsigned int)(input()) + (unsigned int)(m_offset));
\endcode

The member strom::Id2DataPair::data() returns a strom::DataContainer object. As in the previous examples a strom::ReadAccess is needed to extract the actual data from the data container. In the next step the output value is computed and stored in an strom::UInt32 object. The output data is passed to subsequent operators or to the client of the library \em without copying the data. I.e. the object must be allocated on the heap because it should stay alive even if it leaves the scope of \c Add::execute(). 
        
\code
        strom::DataContainer outContainer(result);
       
        strom::Id2DataPair output(OUTPUT, outContainer);
        provider.sendOutputData(output);
    }
} 
\endcode



\section operator_deploy Deploying the operator

\code
#include <strom/Factory.h>
#include <strom/XmlReader.h>
#include <strom/Stream.h>
#include <strom/Strom.h>
#include <strom/Operator.h>
#include <strom/Primitive.h>
#include <strom/ReadAccess.h>

#include <base/Base.h>

#include "math/Add.h"

#include <iostream>

int main (int argc, char* argv[])
{
    using namespace strom;
   
    Factory* factory = new Factory;
    
    registerStrom(factory);
    registerBase(factory);
    
    OperatorKernel* op = new math::Add;
    factory->registerOperator(op);
    
    Stream* stream = XmlReader(factory).read("operator.xml");
    
    stream->start();
    
    Operator* timer = stream->operators()[2];
    
    for(unsigned int i = 0; i < 5; ++i)
    {
        DataContainer data = timer->getOutputData(0);
        ReadAccess<UInt32> count(data);
        timer->clearOutputData(0);
        
        std::cout << "Received " <<  (unsigned int)(count()) << std::endl;
    }
    
    stream->stop();
    stream->join();
    
    delete stream;
}
\endcode

*/

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>stromx: Simple</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stromx-logo-rgb-64x64.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">stromx
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Welcome to stromx!</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Simple </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><em>Streams</em> are the main objects of the <em>core</em> library. All other objects belong either directly or indirectly to a stream. A stream consists of operators each of which can have several input and output <em>connectors</em>. An example of a very simple stream is given in the following image:</p>
<div class="image">
<img src="simple.png" alt="simple.png"/>
</div>
<p>The operator <em>Counter</em> has the single output <em>OUTPUT</em> which is connected to the only input connector (fittingly called <em>INPUT</em>) of <em>PeriodicDelay</em>. This means that every output data which is produced at the output of <em>PeriodicDelay</em> will be transported to the input of <em>Counter</em>. Data which is transported to an input will stay there and <em>block</em> this input until its operator starts to process the data.</p>
<p>However operators in <em>core</em> are <em>passive</em> objects, i.e. they do not process any data on their own but need a <em>thread</em> which <em>executes</em> them. Besides operators, threads are the second important building block of a stream. Each input connector of an operator can be assigned to a thread. When activated the thread visits each of its input connector sequentially and starts over with the first when they last connector has been reached. When a thread visits an input connector of an operator it acts according to the following two steps:</p>
<ul>
<li>The thread looks up to which output the input is connected. If there is no data at this output the thread <em>executes</em> the operator to which the output belongs to. This should produce some data at the output in question.</li>
</ul>
<ul>
<li>Now the thread takes the data which was either present at the output of the source operator or has been produced by executing the source operator and passes it to the input connector which it currently visits. It can however happen that data has already assigned to this connector, i.e. the input connector is blocked. In this case the thread will execute the operator of the input connector hoping that the blocking data will be processed and free its space for the new data.</li>
</ul>
<p>In other words, the process of transporting data from output connectors to input connectors implicitely executes the operators of these connectors to make sure (1) that there is enough data at the outputs and (2) that the data at the inputs is removed in time.</p>
<dl class="section note"><dt>Note:</dt><dd>Not every input connector must be assigned to a thread. However, if data is required at an input which is not part of a thread the input must be fed manually by the user by calling core::Operator::setInputData(). Something similar holds for outputs which are not connected to inputs (more accurate, to inputs which are assigned to a thread). If data is waiting at such an output (which prevents the operator from being executed) it can be removed by the client using core::Operator::clearOutputData().</dd></dl>
<p>The <em>simple</em> tutorial assembles the stream in the image above and operates it. The <em>Counter</em> operator in the stream simply pushes an integer to its output each time it is executed. With each call it increments the integer by one. The <em>PeriodicDelay</em> operator simple passes data at its input to its output. However, it makes sure that new data appears at the output at most once within a certain amount of time (one second in this example). In this sense it acts as a timer, which delays the transport of data by predefined timespan. In the following, the source code of <em>simple.cpp</em> is printed with comments under each part.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;stromx/core/Counter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stromx/core/Operator.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stromx/core/PeriodicDelay.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stromx/core/ReadAccess.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stromx/core/Stream.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;stromx/core/Thread.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
</div><!-- fragment --><p>As usual the program starts be including the required header files. Stromx uses a fine grained approach to the inclusion of headers, i.e. only the necessary headers are included by the library headers and forward declarations are used wherever possible. As a consequence the headers of all classes which are used in the code are included here.</p>
<p>The first four headers are part of the core core library. This library provides all infrastructure to support streams, operators and threads but does not contain any actual operators. The operators which are used in the example are imported next. The final header is necessary to write the results of the running stream to the standard output.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span>stromx;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">int</span>, <span class="keywordtype">char</span>**)</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="classstromx_1_1core_1_1_stream.html" title="The core data processing pipeline of stromx.">core::Stream</a> stream;</div>
</div><!-- fragment --><p>The program starts by creating an empty stream object which will populated with operators and threads in the following.</p>
<div class="fragment"><div class="line">    core::Operator* source = <span class="keyword">new</span> core::Operator(<span class="keyword">new</span> core::Counter);</div>
<div class="line">    source-&gt;initialize();</div>
<div class="line">    stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#a16706c888d08c2f5e009f1b450a2bac4">addOperator</a>(source);</div>
<div class="line">    </div>
<div class="line">    core::Operator* timer = <span class="keyword">new</span> core::Operator(<span class="keyword">new</span> core::PeriodicDelay);</div>
<div class="line">    timer-&gt;initialize();</div>
<div class="line">    stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#a16706c888d08c2f5e009f1b450a2bac4">addOperator</a>(timer);</div>
</div><!-- fragment --><p>First, the source is operator is allocated and initialized. Initializing can possibly change important properties of an operator such as the number and type of its output and input connectors. This is the reason why only initialized operators can be added to a stream. When an operator is added to a stream the stream assumes ownership of it. I.e. its not advisable to add an operator which is allocated on the stack to a stream. This would result in a crash when the stream is destroyed or when the operator goes out of scope. In other words, always use <em>new</em> to allocate an operator before adding it to the stream and do not delete it because the stream will take care of that.</p>
<div class="fragment"><div class="line">    timer-&gt;setParameter(core::PeriodicDelay::PERIOD, core::UInt32(1000));</div>
</div><!-- fragment --><p>In the next step the time delay of the timer operator is set to one second. All data passed as parameter to the function core::Operator::setParameter must be derived from core::Data. Versions of primitive data types which are derived from core::Data are defined in core::Primitive. Here core::UInt32 is used which obviously wraps a 32-bit unsigned integer.</p>
<dl class="section note"><dt>Note:</dt><dd>Each parameter has an access mode which controls when the associated value can be written and read. In case of the period of core::PeriodicCounter the access mode is core::Parameter::ACTIVATED_WRITE which means that the parameter can be written (and read) at any time as soon the operator is initialized.</dd></dl>
<div class="fragment"><div class="line">    stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#a19df4545427371a67048916e64299d22">connect</a>(source, core::Counter::OUTPUT, timer, core::PeriodicDelay::INPUT);</div>
</div><!-- fragment --><p>This line connects the output of the counter to the input of the <code>timer</code> operator. Note that input and output connectors are identified by the operator the belong to (<code>source</code> and <code>timer</code>) and their IDs (core::Counter::OUTPUT and core::PeriodicDelay::INPUT).</p>
<div class="fragment"><div class="line">    core::Thread* thread = stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#a4c221d86c72eac2c81f028597f69059d">addThread</a>();</div>
<div class="line">    thread-&gt;<a class="code" href="classstromx_1_1core_1_1_thread.html#a65546a29a73582b9cde4b04987d4a732">addInput</a>(timer, core::PeriodicDelay::INPUT);</div>
</div><!-- fragment --><p>Now the operating thread is added to the stream. In the next line the input connector of <em>timer</em> is added as the only input connector which is operated by <em>thread</em>. As before the input connector is addressed by its operator and its ID.</p>
<div class="fragment"><div class="line">    stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#a458264a5cd10d15ce4e124d61fd6780b">start</a>();</div>
</div><!-- fragment --><p>This step starts all threads (i.e. is one in our case) of the stream. The thread begins to process its input connectors immediately. As mentioned in the introduction it executes the operators in the stream and moves processed data to the output of <em>timer</em>. The following loop gets this data from the final output and writes it to the standard input.</p>
<div class="fragment"><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)</div>
<div class="line">    {</div>
<div class="line">        core::DataContainer data = timer-&gt;getOutputData(core::PeriodicDelay::OUTPUT);</div>
<div class="line">        core::ReadAccess&lt;core::UInt32&gt; count(data);</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt;  (<span class="keywordtype">unsigned</span> int)(count()) &lt;&lt; std::endl;</div>
<div class="line"></div>
<div class="line">        timer-&gt;clearOutputData(core::PeriodicDelay::OUTPUT);</div>
<div class="line">    }</div>
</div><!-- fragment --><p>Each iteration of the loop starts by obtaining the current data at the output of <code>timer</code>. If data is present at the output function stream::Operator::getOutputData() returns it immediately, otherwise it blocks until data arrives. The data is packaged in a <em>data container</em>. Data containers are basically references to data objects and can be easily copied and therefore moved from one part of the stream to another. They are implemented via shared pointers and make sure the data inside them is deleted as soon nobody holds any referenece (i.e. no containers exist anymore) to it. As their real world counterparts data containers do not only faciliate the transport of data, they also protect it in the sense that they do not allow direct access to the data inside them.To actually read the data stored in the data container a <em>read accessor</em> <code>count</code> has to be constructed around the container. It allows reading <code>data</code> using the () operator as in the next line of the loop.</p>
<dl class="section note"><dt>Note:</dt><dd>As the existence of a read accessor suggests there is also a class core::WriteAccess which allows to write to data stored in a data container. While data can be read simultaneously by many threads, i.e. many core::ReadAccess objects can exist at the same time, only one write access can exist exclusively at a time. If a core::WriteAccess is constructed while other read or write access objects for the same data container exist the constructur blocks until all other accesses are released. If the write access is successfully allocated it is guaranteed to have exclusive write access rights. Other threads can only access the data after the write access goes out of scope or is deleted. This is can be convenient in situations where data should be rather shared than copied such as in case of simultaneous processing of large image data.</dd></dl>
<p>Finally the output of <code>timer</code> has be be cleared. Otherwise the data there would block <code>counter</code> from depositing new data and would eventually obstruct the complete stream.</p>
<div class="fragment"><div class="line">    stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#afc38a7acd077c3cad77b13637586e09f">stop</a>();</div>
<div class="line">    stream.<a class="code" href="classstromx_1_1core_1_1_stream.html#a33291f71e13537ba2e148f8daf2c45c9">join</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><p>After the output of the stream has been received a couple of times the stream is ordered to stop. While core::Stream::stop() is an asynchronous method, joining the stream waits until each thread has come to halt and the stream is inactive.</p>
<p>In this tutorial a stream was assembled by calling respective library functions. However, it can be more convenient to write down the layout of the stream in an XML file and atomatically build it from this file. This is illustrated in the next tutorial <a class="el" href="file.html">File</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1
</small></address>
</body>
</html>

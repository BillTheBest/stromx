<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>stromx: Operator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="stromx-logo-rgb-64x64.png"></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">stromx</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">Welcome to stromx!</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Operator </h1>  </div>
</div>
<div class="contents">
<div class="textblock"><ul>
<li><a class="el" href="operator.html#operator_declare">Declaring the operator</a></li>
<li><a class="el" href="operator.html#operator_implement">Implementing the operator</a></li>
<li><a class="el" href="operator.html#operator_deploy">Deploying the operator</a></li>
</ul>
<p>In this example the stream in previous examples shall be extended by an operator <em>Add</em> which adds a constant offset to the number currently processed:</p>
<div align="center">
<img src="operator.png" alt="operator.png"/>
</div>
<p>However such an operator is not defined in the package <em>Base</em> which provided all operators which have been used so far. Thus, a custom operator <em>Add</em> must be implemented. It will be the single member of the new package <em>Math</em>.</p>
<h2><a class="anchor" id="operator_declare"></a>
Declaring the operator</h2>
<p>A custom operator is implemented by defining an <em>operator kernel</em>. In contrast to operators, operator kernels do not have to be thread-safe. All concurrent accesses are handled by the core::Operator class which wraps the operator kernels. This simplifies the definition of custom operators.</p>
<p>The new operator kernel is declared in the header file <em>Add.h</em>:</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifndef MATH_ADD_H</span>
<span class="preprocessor"></span><span class="preprocessor">#define MATH_ADD_H</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;stromx/core/OperatorKernel.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Primitive.h&gt;</span>

<span class="keyword">using namespace </span>stromx;

<span class="keyword">namespace </span>math
{
    <span class="keyword">class </span>Add : <span class="keyword">public</span> core::<a class="code" href="classstromx_1_1core_1_1_operator_kernel.html" title="Abstract operator kernel.">OperatorKernel</a>
    {
</pre></div><p>The kernel will be a member of the package <em>Math</em>. It seems to be a good practice to add all operators of a package to a common namespace which in this case is consequently called <em>math</em>.</p>
<p>All operator kernels are derived from core::OperatorKernel.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">public</span>:
        <span class="keyword">enum</span> InputId
        {
            INPUT
        };
        
        <span class="keyword">enum</span> OutputId
        {
            OUTPUT
        };
        
        <span class="keyword">enum</span> ParameterId
        {
            OFFSET
        };
</pre></div><p>Each input, output and parameter of the operator is identified by an ID. Here each of these IDs is 0, but any other value is possible as long as it is unique within its category (i.e. inputs, outputs, parameters).</p>
<div class="fragment"><pre class="fragment">        Add();
        
        <span class="keyword">virtual</span> OperatorKernel* <span class="keyword">const</span> clone()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> Add; }
        <span class="keyword">virtual</span> <span class="keywordtype">void</span> execute(core::DataProvider&amp; provider);

        <span class="keyword">virtual</span> <span class="keywordtype">void</span> setParameter(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> core::Data&amp; value);
        <span class="keyword">virtual</span> <span class="keyword">const</span> core::Data&amp; getParameter(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>);
</pre></div><p>First the default constructor is declared. The functions core::OperatorKernel::clone() and core::OperatorKernel::execute() are abstract in core::OperatorKernel and must be defined in each custom operator kernel. The subsequent functions must be implemented to support reading and writing the paramter of <em>Add</em>.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">private</span>:
        <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;const core::Description*&gt; setupInputs();
        <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;const core::Description*&gt; setupOutputs();
        <span class="keyword">static</span> <span class="keyword">const</span> std::vector&lt;const core::Parameter*&gt; setupParameters();
        
        <span class="keyword">static</span> <span class="keyword">const</span> std::string TYPE;
        <span class="keyword">static</span> <span class="keyword">const</span> std::string PACKAGE;
        <span class="keyword">static</span> <span class="keyword">const</span> core::Version VERSION;                         
        
        core::UInt32 m_offset;
    };
}

<span class="preprocessor">#endif // MATH_ADD_H</span>
</pre></div><p>The subsequent private declarations are for internal use only and will be explained when used in the implementation of <em>Add</em>.</p>
<h2><a class="anchor" id="operator_implement"></a>
Implementing the operator</h2>
<p>The operatorar <em>Add</em> is implemented in <em>Add.cpp</em>. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &quot;Add.h&quot;</span>

<span class="preprocessor">#include &lt;stromx/core/Primitive.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/OperatorException.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/DataContainer.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/DataProvider.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Id2DataPair.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Id2DataComposite.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/ReadAccess.h&gt;</span>
</pre></div><p>First all necessary headers are included. The subsequent <em>using</em> allows to access the members of the <em>core</em> library without the prefix <code>core:</code>:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>math
{
    <span class="keyword">const</span> std::string Add::TYPE(<span class="stringliteral">&quot;Add&quot;</span>);
    <span class="keyword">const</span> std::string Add::PACKAGE(<span class="stringliteral">&quot;Math&quot;</span>);
    <span class="keyword">const</span> Version Add::VERSION(1, 0, 0);
</pre></div><p>Each operator kernel provides exports its type, the package it belongs to and its version. This information must be the same for each instance of specific operator class and is naturally stored in static variables. This data will be passed to the constructor of core::OperatorKernel.</p>
<p>Moreover, the constructor of core::OperatorKernel accepts vectors of descriptions of the inputs, outputs and parameters of the operator kernel. These descriptions are <em>not</em> required to be the same for each instance of a specific operator class and can change during the lifetime of operator objects. As a consequence they can not be static variables but must be allocated for each class instance. The following helper functions take care of this allocations. In the case of <em>Add</em> the initial descriptions are the same for each class instance. Thus, the initialization functions can be static.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">const</span> std::vector&lt;const core::Description*&gt; Add::setupInputs()
    {
        std::vector&lt;const core::Description*&gt; inputs;
        
        core::Description* input = <span class="keyword">new</span> core::Description(INPUT, core::DataVariant::UINT_32);
        input-&gt;setName(<span class="stringliteral">&quot;Input&quot;</span>);
        inputs.push_back(input);
        
        <span class="keywordflow">return</span> inputs;
    }
    
    <span class="keyword">const</span> std::vector&lt;const core::Description*&gt; Add::setupOutputs()
    {
        std::vector&lt;const core::Description*&gt; outputs;
        
        core::Description* output = <span class="keyword">new</span> core::Description(OUTPUT, core::DataVariant::UINT_32);
        output-&gt;setName(<span class="stringliteral">&quot;Output&quot;</span>);
        outputs.push_back(output);
        
        <span class="keywordflow">return</span> outputs;
    }
    
    <span class="keyword">const</span> std::vector&lt;const core::Parameter*&gt; Add::setupParameters()
    {
        std::vector&lt;const core::Parameter*&gt; parameters;
        
        core::Parameter* offset = <span class="keyword">new</span> core::Parameter(OFFSET, core::DataVariant::UINT_32);
        offset-&gt;setName(<span class="stringliteral">&quot;Offset&quot;</span>);
        offset-&gt;setAccessMode(core::Parameter::ACTIVATED_WRITE);
        parameters.push_back(offset);
                                    
        <span class="keywordflow">return</span> parameters;
    }
</pre></div><p>Each initialization function allocates an empty vector which contains pointers to core::Description objects (in the case of inputs and outputs) or core::Parameter objects (for parameters). Input and output descriptions only contain their ID, <em>data variants</em> and names. The data variant defines which kind of data is accepted by the input or returned at the output, respectively. In case of parameters it determines the type of the data stored for this parameter.</p>
<p>Parameters additionally provide information about their access mode. Here core::Parameter::ACTIVATED_WRITE means that the parameter can be read and written while the operator is initialized or activated. There exist subclasses of core::Parameter to describe specific types of parameters in more detail. One example is core::NumericParameter which contains information about the minimal and maximal value a parameter can be set to.</p>
<div class="fragment"><pre class="fragment">    Add::Add()
      : OperatorKernel(TYPE, PACKAGE, VERSION, setupInputs(), setupOutputs(), setupParameters())
    {
    }
</pre></div><p>The constructor of <em>Add</em> simply passes all information which was setup above to the constructor of operator kernel.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>Not all inputs, outputs and parameters have to be passed to the constructor of core::OperatorKernel. There exists the possibility to add further information during initialization of the operator (by overloading core::OperatorKernel::initialize()). This means that an operator can be set up in a two stage process. After instantiation (but before initialization) some parameter descriptions are allocated and the corresponding parameters can be set. Depending on the value of these parameters the operators assigns further inputs, outputs and parameters to itself during initialization. An example is an operator which merges several inputs to one output. After instantation the operator has no inputs but a parameter which defines the number of inputs. Only during initialization these inputs are actually allocated.</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classstromx_1_1core_1_1_operator_kernel.html#a63e0152828822f4ddf3e233226a8623c">Add::setParameter</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>, <span class="keyword">const</span> core::Data&amp; value)
    {
        <span class="keywordflow">try</span>
        {
            <span class="keywordflow">switch</span>(<span class="keywordtype">id</span>)
            {
            <span class="keywordflow">case</span> OFFSET:
                m_offset = core::data_cast&lt;<span class="keyword">const</span> core::UInt32&amp;&gt;(value);
                <span class="keywordflow">break</span>;
            <span class="keywordflow">default</span>:
                <span class="keywordflow">throw</span> core::WrongParameterId(<span class="keywordtype">id</span>, *<span class="keyword">this</span>);
            }
        }
        <span class="keywordflow">catch</span>(core::BadCast&amp;)
        {
            <span class="keywordflow">throw</span> core::WrongParameterId(<span class="keywordtype">id</span>, *<span class="keyword">this</span>);
        }
    }
</pre></div><p>The parameter <em>Add</em> supports only one parameter. To support more parameter further <code>case</code> statements have to be added to the <code>switch</code> statement. The value of the parameter <code>OFFSET</code> is internally stored as member of type core::UInt32. Because the parameter <code>value</code> is of type core::Data it must be down-casted to the correct type. The function core::data_cast() works exactly as dynamic_cast() but throws a core::BadCast instead of std::bad_cast.</p>
<div class="fragment"><pre class="fragment">    <span class="keyword">const</span> core::Data&amp; <a class="code" href="classstromx_1_1core_1_1_operator_kernel.html#aea287e484df245e4553fd41d55fcb86f">Add::getParameter</a>(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keywordtype">id</span>)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">switch</span>(<span class="keywordtype">id</span>)
        {
        <span class="keywordflow">case</span> OFFSET:
            <span class="keywordflow">return</span> m_offset;
        <span class="keywordflow">default</span>:
            <span class="keywordflow">throw</span> core::WrongParameterId(<span class="keywordtype">id</span>, *<span class="keyword">this</span>);
        }
    }  
</pre></div><p>The functions to read a parameter follows the same pattern as writing it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>As mentioned above operator kernels do not have to be thread-safe. It is guaranteed that core::OperatorKernel::getParameter() and core::OperatorKernel::setParameter() are never called during execution of the operator.</dd></dl>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> <a class="code" href="classstromx_1_1core_1_1_operator_kernel.html#a54d2f05fd7ece62eaf5b9aadfedcb950">Add::execute</a>(core::DataProvider&amp; provider)
    {
        core::Id2DataPair inputMapper(INPUT);
        provider.receiveInputData(inputMapper);
</pre></div><p>The actual work done by <em>Add</em> happens in <code>execute()</code>. There the input data is processed and the result is passed to the operator output. The input data is obtained from a core::DataProvider object. To request the data of an specific input a core::Id2DataPair object <code>inputMapper</code> is instantiated with the ID of the input in question. The data provider looks up the corresponding input and waits for input data. If the data arrives it stores in <code>inputMapper</code>.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The above procedure to obtain the input data of the operator via data mappers might appear complicated at first sight. However, this approach allows for more flexible strategies to get input data. Consider e.g. an operator which has two inputs but requires only data from one of them at a time. If <code>inputMapper1</code> and <code>inputMapper2</code> map to the respective inputs, the call <code>provider.receiveInputData(inputMapper1 || inputMapper2)</code> returns as soon as one of the inputs received some data. On the other hand, <code>provider.receiveInputData(inputMapper1 &amp;&amp; inputMapper2)</code> waits until both inputs received their data. More complicated expressions of data mappers can be built by combining core::operator&amp;&amp;, core::operator|| and core::Try.</dd></dl>
<div class="fragment"><pre class="fragment">        core::ReadAccess&lt;core::UInt32&gt; input(inputMapper.data());

        core::Data* result = <span class="keyword">new</span> core::UInt32((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(input()) + (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(m_offset));
</pre></div><p>The member core::Id2DataPair::data() returns a core::DataContainer object. As in the previous examples a core::ReadAccess is needed to extract the actual data from the data container. In the next step the output value is computed and stored in an core::UInt32 object. The output data is passed to subsequent operators or to the client of the library <em>without</em> copying the data. I.e. the object must be allocated on the heap because it should stay alive even if it leaves the scope of <code>Add::execute()</code>.</p>
<div class="fragment"><pre class="fragment">        core::DataContainer outContainer(result);
       
        core::Id2DataPair output(OUTPUT, outContainer);
        provider.sendOutputData(output);
    }
} 
</pre></div><p>To send the result data to the output it is packed into a DataContainer and paired with the ID of the respective output. The data provider is responsible to send the data container to the corresponding output. As in the case of core::DataProvider::receiveInputData(), the function core::DataProvider::sendOutputData() accepts expressions core::Id2DataPair objects together with core::operator&amp;&amp;, core::operator|| and core::Try.</p>
<h2><a class="anchor" id="operator_deploy"></a>
Deploying the operator</h2>
<p>Finally, the new operator should be used as a part of a stream. This is simply done by adapting the file which defines the layout of the stream.</p>
<div class="fragment"><pre class="fragment">&lt;?xml version=<span class="stringliteral">&quot;1.0&quot;</span> encoding=<span class="stringliteral">&quot;UTF-8&quot;</span> ?&gt;

&lt;Stromx version=<span class="stringliteral">&quot;0.1.0&quot;</span>&gt;
    &lt;Stream&gt;
        &lt;Operator <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span> package=<span class="stringliteral">&quot;Base&quot;</span> type=<span class="stringliteral">&quot;Counter&quot;</span> version=<span class="stringliteral">&quot;0.1.0&quot;</span>/&gt;
        &lt;Operator <span class="keywordtype">id</span>=<span class="stringliteral">&quot;1&quot;</span> package=<span class="stringliteral">&quot;Math&quot;</span> type=<span class="stringliteral">&quot;Add&quot;</span> version=<span class="stringliteral">&quot;1.0.0&quot;</span>&gt;
            &lt;Parameter <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span>&gt;
                &lt;Data type=<span class="stringliteral">&quot;UInt32&quot;</span> package=<span class="stringliteral">&quot;Core&quot;</span> version=<span class="stringliteral">&quot;0.1.0&quot;</span>&gt;2&lt;/Data&gt;
            &lt;/Parameter&gt;
            &lt;Input <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">operator</span>=<span class="stringliteral">&quot;0&quot;</span> output=<span class="stringliteral">&quot;0&quot;</span>/&gt;
        &lt;/Operator&gt;
        &lt;Operator <span class="keywordtype">id</span>=<span class="stringliteral">&quot;2&quot;</span> package=<span class="stringliteral">&quot;Base&quot;</span> type=<span class="stringliteral">&quot;PeriodicDelay&quot;</span>&gt;
            &lt;Parameter <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span>&gt;
                &lt;Data type=<span class="stringliteral">&quot;UInt32&quot;</span> package=<span class="stringliteral">&quot;Core&quot;</span> version=<span class="stringliteral">&quot;0.1.0&quot;</span>&gt;1000&lt;/Data&gt;
            &lt;/Parameter&gt;
            &lt;Input <span class="keywordtype">id</span>=<span class="stringliteral">&quot;0&quot;</span> <span class="keyword">operator</span>=<span class="stringliteral">&quot;1&quot;</span> output=<span class="stringliteral">&quot;0&quot;</span>/&gt;
        &lt;/Operator&gt;
        &lt;Thread name=<span class="stringliteral">&quot;&quot;</span>&gt;
            &lt;InputNode <span class="keyword">operator</span>=<span class="stringliteral">&quot;1&quot;</span> input=<span class="stringliteral">&quot;0&quot;</span>/&gt;
            &lt;InputNode <span class="keyword">operator</span>=<span class="stringliteral">&quot;2&quot;</span> input=<span class="stringliteral">&quot;0&quot;</span>/&gt;
        &lt;/Thread&gt; 
    &lt;/Stream&gt;
&lt;/Stromx&gt;
</pre></div><p>The program which runs the stream is almost identical to the one in the previous tutorial. The only extra step which has to be taken is the registration of the operator <em>Add</em> with the factory.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stromx/core/Factory.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/XmlReader.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Stream.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Core.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Operator.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/Primitive.h&gt;</span>
<span class="preprocessor">#include &lt;stromx/core/ReadAccess.h&gt;</span>


<span class="preprocessor">#include &lt;stromx/base/Base.h&gt;</span>

<span class="preprocessor">#include &quot;math/Add.h&quot;</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="keyword">using namespace </span>stromx;

<span class="keywordtype">int</span> main (<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
    <span class="keyword">using namespace </span>core;
   
    Factory* factory = <span class="keyword">new</span> Factory;
    
    stromxRegisterCore(factory);
    stromxRegisterBase(factory);

    <a class="code" href="classstromx_1_1core_1_1_operator_kernel.html" title="Abstract operator kernel.">OperatorKernel</a>* op = <span class="keyword">new</span> math::Add;
    factory-&gt;<a class="code" href="classstromx_1_1core_1_1_factory.html#a7ce8255d5e177536141caf815a8bd746">registerOperator</a>(op);
</pre></div><p>To register a single operator one object of its class has to be instantiated and passed to the factory.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If the package <em>Math</em> contained more operators and was built as separate shared object it would make sense to define a function <code>registerMath()</code> in the shared object which registered all operators in <em>Math</em>.</dd></dl>
<div class="fragment"><pre class="fragment">    Stream* stream = XmlReader().readStream(<span class="stringliteral">&quot;operator.xml&quot;</span>, factory);
    
    stream-&gt;start();
    
    Operator* timer = stream-&gt;operators()[2];
    
    <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 5; ++i)
    {
        DataContainer data = timer-&gt;getOutputData(0);
        ReadAccess&lt;UInt32&gt; count(data);
        timer-&gt;clearOutputData(0);
        
        std::cout &lt;&lt; <span class="stringliteral">&quot;Received &quot;</span> &lt;&lt;  (<span class="keywordtype">unsigned</span> int)(count()) &lt;&lt; std::endl;
    }
    
    stream-&gt;stop();
    stream-&gt;join();
    
    <span class="keyword">delete</span> stream;
}
</pre></div><p>Using the presented technique allows to implement single steps of a data processing pipeline in a <em>stromx</em> operator. These operators can then be combined arbitrarily to form new processing networks.</p>
<p>It is possible to define custom data types in a similar fashion by subclassing core::Data and core::DataVariant.</p>
<p>The tutorial <a class="el" href="camera.html">Camera</a> how to process images orginating from a simulated camera. </p>
</div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Thu May 3 2012 20:46:54 for stromx by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
